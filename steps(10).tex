%\documentclass[11pt]{article}


%\begin{document}
    
%    \maketitle
    
    

    
    \hypertarget{aplicaciuxf3n-de-algoritmo-rollingball}{%
\section{Aplicación de algoritmo
RollingBall}\label{aplicaciuxf3n-de-algoritmo-rollingball}}

En este script se pretende replicar la experiencia con el algoritmo
rollingball del paquete {[}baseline{]} de R.

    Inicialmente se deben tener instalados los paquetes necesarios para el
procesamiento de las imágenes.

Este paso puede \textbf{omitirse} si ya se encuentra instalado.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nf}{install.packages}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{ggplot2\PYZdq{}}\PY{p}{)}
\PY{n+nf}{install.packages}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{imager\PYZdq{}}\PY{p}{)}
\PY{n+nf}{install.packages}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{mixtools\PYZdq{}}\PY{p}{)}
\PY{n+nf}{install.packages}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{baseline\PYZdq{}}\PY{p}{)}
\PY{n+nf}{install.packages}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Matrix\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

   

    El primer paso consiste en cargar la imagen en una variable. La
representación de la imagen está en el espacio de color RGB.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}Load and plot the RGB file}
\PY{c+c1}{\PYZsh{}data.file \PYZlt{}\PYZhy{} \PYZsq{}/mnt/usb\PYZhy{}WD\PYZus{}Elements\PYZus{}25A2\PYZus{}575852314531383859503438\PYZhy{}0:0\PYZhy{}part1/CHB/PASANTIA/imagenes\PYZus{}forestal/data/DJI\PYZus{}0805.jpg\PYZsq{}}
\PY{n}{data.file} \PY{o}{\PYZlt{}\PYZhy{}} \PY{l+s}{\PYZsq{}}\PY{l+s}{../imagenes\PYZus{}forestal/data/original\PYZus{}referencia.jpg\PYZsq{}}
\PY{n}{im} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{load.image}\PY{p}{(}\PY{n}{data.file}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    A los efectos de procesar la porción central de la imagen y reducir así
los efectos de distorsión de perspectiva por desvío de la línea vertical
nadir-cenit, además de proporcionar una reducción del tamaño de la
imagen, se realiza un recorte de la imagen en 300 x 300 píxeles. Una vez
que la imagen se encuentra cargada en la variable, es posible imprimir
el gráfico con la función plot

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}im\PYZlt{}\PYZhy{}im[200:500,200:500,]}
\PY{n+nf}{plot}\PY{p}{(}\PY{n}{im}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_10_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    La imagen con la que se trabaja fue obtenida por medio de un dron que
sobrevolaba la \href{https://sib.gob.ar/area/MISIONES*YB*YABOTY}{reserva
biósfera Yaboty}, a una altitud aproximada de 600 metros. La resolución
de la imagen original es de 12 Mpixels (4000 x 3000), pero fue reducida
a una resolución de 1000 x 750 pixels para aliviar la carga de
procesamiento.

    Teniendo en cuenta los datos del vuelo, de la
\href{https://www.dji.com/phantom-4/info}{cámara} y del terreno, podemos
hallar que la resolución espacial de la fotografía aérea es de 0,5 metro
por pixel, aproximadamente (esto teniendo en cuenta que la imagen
original fue reducida en su resolución original de 4000 x 3000 pixeles a
1000 x 750 pixeles)

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}data.file \PYZlt{}\PYZhy{} \PYZsq{}../Captura.png\PYZsq{}}
\PY{c+c1}{\PYZsh{}recorte \PYZlt{}\PYZhy{} load.image(data.file)}
\PY{c+c1}{\PYZsh{}plot(recorte)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}data.file \PYZlt{}\PYZhy{} \PYZsq{}../copa\PYZus{}referencia.png\PYZsq{}}
\PY{c+c1}{\PYZsh{}recorte \PYZlt{}\PYZhy{} load.image(data.file)}
\PY{c+c1}{\PYZsh{}plot(recorte)}
\end{Verbatim}
\end{tcolorbox}

    Una observación en la imagen del recorte de la copa permite estimar el
tamaño que abarca la copa en 80 píxeles. Este dato será usado en los
parámetros de los filtro implementados.

    Para procesar la imagen, debe ser convertida al espacio de color
\href{https://es.wikipedia.org/wiki/Modelo_de_color_HSL}{HSL}, del cual
se tomará la componente \textbf{L} de luminosidad.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}GPerforms the conversion of the image from RGB to HSL colorspace}
\PY{n}{im\PYZus{}hsl} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{RGBtoHSL}\PY{p}{(}\PY{n}{im}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nf}{plot}\PY{p}{(}\PY{n}{im\PYZus{}hsl}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_18_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    El aspecto de la imagen visualizada en su componente L del espacio HSL
es de escala de grises\ldots{}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}prints the image L channel from the HSL colorspace. index 3 is L}
\PY{n+nf}{plot}\PY{p}{(}\PY{n+nf}{channel}\PY{p}{(}\PY{n}{im\PYZus{}hsl}\PY{p}{,} \PY{l+m}{3}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_20_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Se extrae la componente L de la imagen HSL y se la almacena en una
variable

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}Extracts the L component from HSL colorspace image}
\PY{c+c1}{\PYZsh{}im\PYZus{}L \PYZlt{}\PYZhy{} im\PYZus{}hsl[200:500,200:500,3]}
\PY{n}{im\PYZus{}L} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{im\PYZus{}hsl}\PY{n}{[}\PY{p}{,}\PY{p}{,}\PY{l+m}{3}\PY{n}{]}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]

\end{Verbatim}
\end{tcolorbox}

    \hypertarget{estimaciuxf3n-de-paruxe1metros-de-distribuciuxf3n-bimodal}{%
\section{Estimación de parámetros de distribución
bimodal}\label{estimaciuxf3n-de-paruxe1metros-de-distribuciuxf3n-bimodal}}

    La función normalmixEM() devuelve una estimación de parámetros de la
distribución de los datos de la componente L de la imagen,
considerándola como una distribución normal bimodal\ldots{}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}Estimation of bimodal distribution parameters}
\PY{n}{param} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{normalmixEM}\PY{p}{(}\PY{n+nf}{as.vector}\PY{p}{(}\PY{n}{im\PYZus{}L}\PY{p}{)}\PY{p}{)}
\PY{n}{param}\PY{o}{\PYZdl{}}\PY{n}{mu}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
number of iterations= 85
    \end{Verbatim}

    \begin{enumerate*}
\item 0.428272211609674
\item 0.562703451765472
\end{enumerate*}


    
    Desplegamos un histograma de los datos del canal L

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{im\PYZus{}L}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_28_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \hypertarget{algoritmo-rolling-ball}{%
\section{Algoritmo Rolling ball}\label{algoritmo-rolling-ball}}

    Se aplica la función baseline() con el método rollingBall y se grafica
el resultado. Los parámetros wm y ws corresponden al ancho de ventana
local de minimización y maximización y de suavizado respectivamente.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}Rolling ball algorithm}

\PY{c+c1}{\PYZsh{}bc.rollingBall \PYZlt{}\PYZhy{} baseline(im\PYZus{}L, wm=80, ws=80, method=\PYZsq{}rollingBall\PYZsq{})}
\PY{c+c1}{\PYZsh{}\PYZsh{} Not run: }
\PY{c+c1}{\PYZsh{}plot(bc.rollingBall)}
\end{Verbatim}
\end{tcolorbox}

    Para visualizar el efecto del filtro aplicado mediante el algoritmo
RollingBall convertimos los datos corregidos al formato cimg mediante la
función as.cimg() y graficamos.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}corregido \PYZlt{}\PYZhy{} as.cimg(bc.rollingBall@corrected)}
\PY{c+c1}{\PYZsh{}plot(corregido)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{operaciones-matemuxe1ticas-morfoluxf3gicas}{%
\section{Operaciones matemáticas
morfológicas}\label{operaciones-matemuxe1ticas-morfoluxf3gicas}}

    Se utilizan los operadores matemáticos morfológicos de transformaciones
top hat y bottom hat, para mejorarse el contraste, basándose en un
elemento estructural.

    \textbf{Top hat}: es la imagen original en grises menos el resultado de
la apertura (\emph{erosión} secundada por \emph{dilación})

\textbf{Bottom hat}: es la imagen resultante de la cerradura
(\emph{dilación} secundada por \emph{erosión}) menos la image original
en grises Combinando ambos se obtiene el mejoramiento del contraste
sumando a la imagen original el resultado de la transformación top hat y
restando el resultado de la transformación bottom hat:
\emph{If=I+Ith-Ibh}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}Top hat y bottom hat}
\PY{c+c1}{\PYZsh{}mask \PYZlt{}\PYZhy{} imfill(78,78,val=1)}
\PY{c+c1}{\PYZsh{}top\PYZus{}hat \PYZlt{}\PYZhy{} as.cimg(im\PYZus{}L) \PYZhy{} mopening(as.cimg(im\PYZus{}L),mask)}
\PY{c+c1}{\PYZsh{}bottom\PYZus{}hat \PYZlt{}\PYZhy{}  mclosing(as.cimg(im\PYZus{}L),mask) \PYZhy{} as.cimg(im\PYZus{}L)}
\PY{c+c1}{\PYZsh{}im\PYZus{}filt \PYZlt{}\PYZhy{} as.cimg(im\PYZus{}L) + top\PYZus{}hat \PYZhy{} bottom\PYZus{}hat}
\PY{c+c1}{\PYZsh{}plot(im\PYZus{}filt)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{primer-identificaciuxf3n-de-objetos-oscuros}{%
\section{3. Primer identificación de objetos
oscuros}\label{primer-identificaciuxf3n-de-objetos-oscuros}}

\textbf{ENTRADA}: escala de grises (canal L)

\textbf{SALIDA}: sombras interarbóreas intensificadas

Se lleva a cabo una primera identificación de objetos oscuros,
definiéndolos como los que tienen un valor por debajo de la media en la
distribución de grises en brechas (hallada mediante el algoritmo
normalmixEM), y a éstos se los iguala a cero.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{TI\PYZus{}abs} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{proc.time}\PY{p}{(}\PY{p}{)}
\PY{n}{entrada3} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{im\PYZus{}L}
\PY{c+c1}{\PYZsh{}values of image that are lower than mean are set to 0}
\PY{n}{salida3} \PY{o}{\PYZlt{}\PYZhy{}} \PY{p}{(}\PY{n}{entrada3}\PY{o}{\PYZgt{}}\PY{n}{param}\PY{o}{\PYZdl{}}\PY{n}{mu}\PY{n}{[1}\PY{n}{]}\PY{p}{)}\PY{o}{*}\PY{n}{entrada3}
\PY{n+nf}{plot}\PY{p}{(}\PY{n+nf}{as.cimg}\PY{p}{(}\PY{n}{salida3}\PY{p}{)}\PY{p}{)}
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{entrada3}\PY{p}{)}
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{salida3}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_39_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_39_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_39_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \hypertarget{relleno-de-sombras-en-grandes-copas-de-uxe1rboles}{%
\section{4. Relleno de sombras en grandes copas de
árboles}\label{relleno-de-sombras-en-grandes-copas-de-uxe1rboles}}

\textbf{ENTRADA}: escala de grises (canal L)

\textbf{SALIDA}: imagen filtrada

La imagen en escala de grises (canal L) se invierte y se le suma el
máximo valor de la escala de grises. Esto es comparable con una imagen
negativa. Se computan dos imágenes baseline mediante un filtro
RollingBall con un radio de tres píxeles. Las imágenes obtenidas se
vuelven a invertir, y los valores máximos de la escala de grises se
usaron para obtener la imagen final suavizada.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{17}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{entrada4} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{im\PYZus{}L}
\PY{c+c1}{\PYZsh{}inversion of grayscale image and addition of maximum grayscale value}
\PY{n}{im\PYZus{}L\PYZus{}inv} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{entrada4}\PY{o}{*}\PY{p}{(}\PY{l+m}{\PYZhy{}1}\PY{p}{)}\PY{o}{+}\PY{n+nf}{max}\PY{p}{(}\PY{n}{entrada4}\PY{p}{)}
\PY{c+c1}{\PYZsh{}both baselines bline1 and bline2 are computed considering one input as inverted image and the other input as transposed inverted image}
\PY{n}{bline1} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{baseline}\PY{p}{(}\PY{n+nf}{t}\PY{p}{(}\PY{n}{im\PYZus{}L\PYZus{}inv}\PY{p}{)}\PY{p}{,}\PY{n}{wm}\PY{o}{=}\PY{l+m}{12}\PY{p}{,} \PY{n}{ws}\PY{o}{=}\PY{l+m}{12}\PY{p}{,} \PY{n}{method}\PY{o}{=}\PY{l+s}{\PYZsq{}}\PY{l+s}{rollingBall\PYZsq{}}\PY{p}{)}
\PY{n}{bline2} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{baseline}\PY{p}{(}\PY{n}{im\PYZus{}L\PYZus{}inv}\PY{p}{,}\PY{n}{wm}\PY{o}{=}\PY{l+m}{12}\PY{p}{,} \PY{n}{ws}\PY{o}{=}\PY{l+m}{12}\PY{p}{,} \PY{n}{method}\PY{o}{=}\PY{l+s}{\PYZsq{}}\PY{l+s}{rollingBall\PYZsq{}}\PY{p}{)}
\PY{c+c1}{\PYZsh{}smooth image}
\PY{n}{im\PYZus{}smooth} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{pmax}\PY{p}{(}\PY{n+nf}{t}\PY{p}{(}\PY{n}{bline1}\PY{o}{@}\PY{n}{baseline}\PY{p}{)}\PY{o}{*}\PY{p}{(}\PY{l+m}{\PYZhy{}1}\PY{p}{)}\PY{p}{,}\PY{p}{(}\PY{n}{bline2}\PY{o}{@}\PY{n}{baseline}\PY{p}{)}\PY{o}{*}\PY{p}{(}\PY{l+m}{\PYZhy{}1}\PY{p}{)}\PY{p}{)}
\PY{n+nf}{plot}\PY{p}{(}\PY{n+nf}{as.cimg}\PY{p}{(}\PY{n}{im\PYZus{}smooth}\PY{p}{)}\PY{p}{)}
\PY{n}{salida4} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{im\PYZus{}smooth}
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{entrada4}\PY{p}{)}
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{salida4}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_41_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_41_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_41_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \hypertarget{identificar-y-rellenar-huecos-en-grandes-copas-de-uxe1rboles}{%
\section{5. Identificar y rellenar huecos en grandes copas de
árboles}\label{identificar-y-rellenar-huecos-en-grandes-copas-de-uxe1rboles}}

\textbf{ENTRADA}:

\textbf{SALIDA}:

Se identifican las copas con un diámetro mayor a 15 píxeles, que
corresponde a 7,5 metros, mediante una transformación top hat. Para ello
se utiliza un elemento estructurante circular con un diámetro de 15
píxeles. El resultado de esto es una máscara binaria que contiene
solamente las copas de diámetro mayor a 15 píxeles. Los huecos son
rellenados entonces con los valores de escala de grises obtenidos
anteriormente.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{entrada5} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{salida3}
\PY{c+c1}{\PYZsh{}Top hat}
\PY{c+c1}{\PYZsh{}Structuring element consists in a circular shape of determined radius}
\PY{n}{radio} \PY{o}{\PYZlt{}\PYZhy{}} \PY{l+m}{14} \PY{c+c1}{\PYZsh{}radius of 7 pixels, corresponding to crown diameter; con 14 se da un mejor resultado usando la imagen original de referencia}
\PY{n}{mask} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{px.circle}\PY{p}{(}\PY{n}{radio}\PY{p}{)}

\PY{n}{abertura} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{mopening}\PY{p}{(}\PY{n+nf}{as.cimg}\PY{p}{(}\PY{n}{entrada5}\PY{p}{)}\PY{p}{,}\PY{n}{mask}\PY{p}{,}\PY{n}{real\PYZus{}mode} \PY{o}{=} \PY{k+kc}{FALSE}\PY{p}{)}
\PY{n}{t\PYZus{}hat} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{as.cimg}\PY{p}{(}\PY{n}{entrada5}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{abertura}
\PY{n}{abertura} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{abertura}\PY{o}{\PYZgt{}}\PY{l+m}{0}
\PY{n+nf}{plot}\PY{p}{(}\PY{n+nf}{as.cimg}\PY{p}{(}\PY{n}{abertura}\PY{p}{)}\PY{p}{)}
\PY{n}{maskara} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{abertura}\PY{n}{[}\PY{p}{,}\PY{p}{,}\PY{l+m}{1}\PY{p}{,}\PY{l+m}{1}\PY{n}{]}
\PY{n}{salida5} \PY{o}{\PYZlt{}\PYZhy{}} \PY{p}{(}\PY{n}{maskara}\PY{o}{*}\PY{n}{salida4}\PY{p}{)}\PY{o}{*}\PY{p}{(}\PY{l+m}{\PYZhy{}2}\PY{p}{)}

\PY{n+nf}{plot}\PY{p}{(}\PY{n+nf}{as.cimg}\PY{p}{(}\PY{n}{salida5}\PY{p}{)}\PY{p}{)}
\PY{n}{salida5} \PY{o}{\PYZlt{}\PYZhy{}} \PY{p}{(}\PY{p}{(}\PY{o}{!}\PY{n}{maskara}\PY{o}{\PYZam{}}\PY{n}{entrada5}\PY{p}{)}\PY{o}{*}\PY{n}{entrada5}\PY{o}{+}\PY{n}{salida5}\PY{p}{)}
\PY{n+nf}{plot}\PY{p}{(}\PY{n+nf}{as.cimg}\PY{p}{(}\PY{n}{salida5}\PY{p}{)}\PY{p}{)}
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{entrada5}\PY{p}{)}
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{salida5}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_43_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_43_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_43_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_43_3.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_43_4.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \hypertarget{segunda-identificaciuxf3n-de-objetos-oscuros}{%
\section{6. Segunda identificación de objetos
oscuros¶}\label{segunda-identificaciuxf3n-de-objetos-oscuros}}

\textbf{ENTRADA}: salida de la etapa 5

\textbf{SALIDA}: imagen de copas sin sombra interna

Bajo la asunción de que la mayoría de los píxeles sombreados de las
copas fueron removidos, se lleva a cabo una identificación final de
píxeles oscuros, los cuales son definidos como los píxeles de escala de
grises que son menores al 99° percentil en la distribuciones en huecos,
y se los iguala a cero.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{entrada6} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{salida5}
\PY{c+c1}{\PYZsh{}a normal distribution (n\PYZus{}gaps) is generated, using the parameters that were found with normalmixEM (eg. the media and standard deviation)}
\PY{n}{n\PYZus{}gaps} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{rnorm}\PY{p}{(}\PY{n+nf}{length}\PY{p}{(}\PY{n}{entrada6}\PY{p}{)}\PY{p}{,} \PY{n}{mean} \PY{o}{=} \PY{n}{param}\PY{o}{\PYZdl{}}\PY{n}{mu}\PY{n}{[1}\PY{n}{]}\PY{p}{,} \PY{n}{sd} \PY{o}{=} \PY{n}{param}\PY{o}{\PYZdl{}}\PY{n}{sigma}\PY{n}{[1}\PY{n}{]}\PY{p}{)}
\PY{n}{noventaynueve} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{quantile}\PY{p}{(}\PY{n}{n\PYZus{}gaps}\PY{p}{,}\PY{l+m}{.99}\PY{p}{)}
\PY{n}{salida6} \PY{o}{\PYZlt{}\PYZhy{}} \PY{p}{(}\PY{o}{!}\PY{p}{(}\PY{n}{entrada6}\PY{n}{[}\PY{p}{,}\PY{n}{]}\PY{o}{\PYZlt{}}\PY{n}{noventaynueve}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{n}{entrada6}
\PY{n+nf}{plot}\PY{p}{(}\PY{n+nf}{as.cimg}\PY{p}{(}\PY{n}{salida6}\PY{p}{)}\PY{p}{)}
\PY{n}{noventaynueve}
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{entrada6}\PY{p}{)}
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{salida6}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \textbf{99\textbackslash{}\%:} 0.491233922282426

    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_45_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_45_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_45_3.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]

\end{Verbatim}
\end{tcolorbox}

    \hypertarget{hallar-pequeuxf1os-huecos-en-grandes-copas}{%
\section{7. Hallar pequeños huecos en grandes
copas¶}\label{hallar-pequeuxf1os-huecos-en-grandes-copas}}

\textbf{ENTRADA}: escala de grises (im\_L)

\textbf{SALIDA}: imagen binaria

Las copas grandes poseen píxeles sueltos de sombra que deben ser
rellenados para luego calcular la distancia de los píxeles al borde (o
sea los píxeles oscuros). Mediante una ventana de 7 x 7 píxeles se
calcula la ocurrencia de valores distintos de cero entorno a cada píxel,
los cuales poseen una distribución bimodal. Los huecos en las copas se
definen como aquellos que están por encima del 75° percentil. Al final
de esta etapa se identifican tres clases de píxel: los de sombra entre
árboles, los no sombreados en las copas y los aislados de sombras en las
copas. Con estas tres clases se compone una máscara binaria con 0 para
píxeles fuera de copas y 1 para los interiores de copas.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{entrada7} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{salida6}
\PY{n}{ti} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{proc.time}\PY{p}{(}\PY{p}{)}
\PY{n}{mat\PYZus{}riz}\PY{o}{\PYZlt{}\PYZhy{}}\PY{n+nf}{cbind}\PY{p}{(}\PY{l+m}{0}\PY{p}{,}\PY{l+m}{0}\PY{p}{,}\PY{l+m}{0}\PY{p}{,}\PY{n}{entrada7}\PY{p}{,}\PY{l+m}{0}\PY{p}{,}\PY{l+m}{0}\PY{p}{,}\PY{l+m}{0}\PY{p}{)} \PY{c+c1}{\PYZsh{}se rellenan tres columnas con ceros por izquierda y por derecha}
\PY{n}{mat\PYZus{}riz}\PY{o}{\PYZlt{}\PYZhy{}}\PY{n+nf}{rbind}\PY{p}{(}\PY{l+m}{0}\PY{p}{,}\PY{l+m}{0}\PY{p}{,}\PY{l+m}{0}\PY{p}{,}\PY{n}{mat\PYZus{}riz}\PY{p}{,}\PY{l+m}{0}\PY{p}{,}\PY{l+m}{0}\PY{p}{,}\PY{l+m}{0}\PY{p}{)} \PY{c+c1}{\PYZsh{}se rellenan tres filas con ceros por arriba y por abajo}
\PY{n}{MNZ} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{entrada7}\PY{o}{*}\PY{l+m}{0} \PY{c+c1}{\PYZsh{}MNZ es una matriz de la misma dimensión que mat\PYZus{}riz completa con ceros}

\PY{n+nf}{for }\PY{p}{(}\PY{n}{i} \PY{n}{in} \PY{l+m}{3}\PY{o}{:}\PY{n+nf}{dim}\PY{p}{(}\PY{n}{entrada7}\PY{p}{)}\PY{n}{[1}\PY{n}{]}\PY{l+m}{+2}\PY{p}{)} \PY{p}{\PYZob{}} \PY{c+c1}{\PYZsh{}i es el índice que recorre las columnas}
   \PY{n+nf}{for }\PY{p}{(}\PY{n}{j} \PY{n}{in} \PY{l+m}{3}\PY{o}{:}\PY{n+nf}{dim}\PY{p}{(}\PY{n}{entrada7}\PY{p}{)}\PY{n}{[2}\PY{n}{]}\PY{l+m}{+2}\PY{p}{)} \PY{p}{\PYZob{}} \PY{c+c1}{\PYZsh{}j es el índice que recorre las filas}
       \PY{n}{a} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{i}\PY{l+m}{\PYZhy{}2}
       \PY{n}{b} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{i}\PY{l+m}{+4}
       \PY{n}{c} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{j}\PY{l+m}{\PYZhy{}2}
       \PY{n}{d} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{j}\PY{l+m}{+4}
       \PY{n}{ventana} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{mat\PYZus{}riz}\PY{n}{[a}\PY{o}{:}\PY{n}{b}\PY{p}{,}\PY{n}{c}\PY{o}{:}\PY{n}{d}\PY{n}{]}
       \PY{n}{MNZ}\PY{n}{[i}\PY{l+m}{\PYZhy{}2}\PY{p}{,}\PY{n}{j}\PY{l+m}{\PYZhy{}2}\PY{n}{]} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{nnzero}\PY{p}{(}\PY{n}{ventana}\PY{p}{)}
   \PY{p}{\PYZcb{}}
   
 \PY{p}{\PYZcb{}}
\PY{p}{(}\PY{n}{delta} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{proc.time}\PY{p}{(}\PY{p}{)}\PY{o}{\PYZhy{}}\PY{n}{ti}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    
    \begin{verbatim}
   user  system elapsed 
   9.13    0.05    9.25 
    \end{verbatim}

    
    En el artículo de referencia se toma un valor de cuantil del 75\%; se ha
probado con un valor que se acerca al 94\% percentil, ya que ahí el
resultado es una matriz nula (todo negro)

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{21}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{(}\PY{n}{setentaycinco} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n+nf}{quantile}\PY{p}{(}\PY{n}{entrada7}\PY{p}{,}\PY{l+m}{.75}\PY{p}{)}\PY{p}{)}
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{MNZ}\PY{p}{)}
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{entrada7}\PY{p}{)}
\PY{n}{huecos\PYZus{}copas} \PY{o}{\PYZlt{}\PYZhy{}} \PY{p}{(}\PY{n}{MNZ}\PY{o}{\PYZgt{}}\PY{n}{setentaycinco}\PY{p}{)}\PY{o}{*}\PY{n}{entrada7}
\PY{n}{salida7} \PY{o}{\PYZlt{}\PYZhy{}} \PY{n}{huecos\PYZus{}copas}
\PY{n+nf}{hist}\PY{p}{(}\PY{n}{salida7}\PY{p}{)}
\PY{n+nf}{plot}\PY{p}{(}\PY{n+nf}{as.cimg}\PY{p}{(}\PY{n}{huecos\PYZus{}copas}\PY{p}{)}\PY{p}{)}
\PY{n+nf}{plot}\PY{p}{(}\PY{n+nf}{as.cimg}\PY{p}{(}\PY{n}{MNZ}\PY{o}{\PYZgt{}}\PY{n}{setentaycinco}\PY{p}{)}\PY{p}{)}
\PY{n+nf}{plot}\PY{p}{(}\PY{n+nf}{as.cimg}\PY{p}{(}\PY{n}{MNZ}\PY{p}{)}\PY{p}{)}

\PY{n+nf}{proc.time}\PY{p}{(}\PY{p}{)}\PY{o}{\PYZhy{}}\PY{n}{TI\PYZus{}abs}
\end{Verbatim}
\end{tcolorbox}

    \textbf{75\textbackslash{}\%:} 0.607843137254902

    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_50_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_50_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_50_3.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_50_4.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_50_5.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    
    \begin{verbatim}
   user  system elapsed 
  23.87    0.86   21.69 
    \end{verbatim}

    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_50_7.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \hypertarget{homogenizaciuxf3n-de-valores-de-escala-de-grises-en-grandes-copas}{%
\section{8. Homogenización de valores de escala de grises en grandes
copas}\label{homogenizaciuxf3n-de-valores-de-escala-de-grises-en-grandes-copas}}

\textbf{ENTRADA}: escala de grises (canal L)

\textbf{SALIDA}: imagen binaria

Para homogenizar los valores en grises en grandes copas, se calcula la
distancia mínima entre valores distinto de cero y el valor de cero de la
máscara precedente. Todos los píxeles con distancia mayor a 7 se
identifican como grandes árboles, y se rellenan con el valor de la media
de los cuatro valores mayores dentro de una ventana de 7 x 7 píxeles.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]

\end{Verbatim}
\end{tcolorbox}

    \hypertarget{extracciuxf3n-de-copas-antes-de-la-segmentaciuxf3n}{%
\section{9. Extracción de copas antes de la
segmentación}\label{extracciuxf3n-de-copas-antes-de-la-segmentaciuxf3n}}

\textbf{ENTRADA}: escala de grises (canal L)

\textbf{SALIDA}: imagen binaria

Las copas con diámetro mayor a 3 metros se extraen mediante un filtro
top bottom hat con elemento estructural cuadrado de 6 x 6 píxeles. A
partir de esa imagen transformada, se aplica un umbral mayor a 0,001°
percentil del filtro.

    \hypertarget{delineaciuxf3n-de-copas-individuales}{%
\section{10. Delineación de copas
individuales}\label{delineaciuxf3n-de-copas-individuales}}

\textbf{ENTRADA}: escala de grises (canal L)

\textbf{SALIDA}: imagen binaria

Se calcula la distancia entre valores cero y distinto de cero, es decir
la distancia del píxel en la copa al borde. Procesando de manera
separada por copas o grupos de copas, calculando las distancias de
píxeles a los bordes. Luego se calcula el máximo local en una ventana
cuadrada de la máxima distancia al borde del segmento. Para cada máximo
local se genera una imagen mediante la dilatación entorno a su locación,
con un tamaño que duplique el diámetro.

    \hypertarget{conclusiones}{%
\section{Conclusiones}\label{conclusiones}}

    


    % Add a bibliography block to the postdoc
    
    
    
%\end{document}
